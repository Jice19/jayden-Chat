<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>虚拟列表 Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* 容器样式 */
        #app {
            width: 375px;
            height: 667px;
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden; /* 内部滚动，外部隐藏 */
            position: relative;
        }

        /* 头部 */
        header {
            height: 60px;
            background: #1890ff;
            color: #fff;
            align-items: center;
            display: flex;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
        }

        /* 列表视口（Viewport） */
        #list-view {
            position: absolute;
            top: 60px;
            bottom: 0;
            left: 0;
            right: 0;
            overflow-y: auto; /* 开启原生滚动 */
            -webkit-overflow-scrolling: touch;
        }

        /* 幽灵占位区域（Phantom）- 用于撑开滚动条 */
        #list-phantom {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            z-index: -1;
        }

        /* 真实列表容器 */
        #list-content {
            position: absolute;
            left: 0;
            right: 0;
            top: 0;
        }

        /* 列表项样式 */
        .list-item {
            padding: 16px;
            border-bottom: 1px solid #eee;
            background: #fff;
            display: flex;
            flex-direction: column;
        }
        .item-head {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        .item-title {
            font-size: 16px;
            color: #333;
            line-height: 1.6;
        }
        .item-img {
            background: #eee;
            margin-top: 8px;
            border-radius: 4px;
            display: flex;
        }

        /* 调试面板 */
        #debug-panel {
            background: rgba(0,0,0,0.7);
            color: #fff;
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="app">
        <header>不高度虚拟列表 Demo</header>
        <div id="list-phantom"></div>
        <div id="list-view">
            <div id="list-content"></div>
        </div>
    </div>

    <div id="debug-panel">
        Rendered: <span id="render-count">0</span> items<br>
        FPS: <span id="fps">0</span><br>
        Start Index: <span id="start-index">0</span>
    </div>

    <script>
        // ================= 模拟数据生成器（Mock Data） =================
        const TOTAL_COUNT = 10000; // 模拟1万条数据
        const data = [];

        // 生成随机文本
        function getRandomText() {
            const str = "性能优化是一个系统工程涉及渲染原理算法多线程计算等核心知识点";
            const len = Math.floor(Math.random() * 100) + 10; // 随机10-110个字
            let res = "";
            for(let i=0; i<len; i++) {
                res += str[Math.floor(Math.random() * str.length)];
            }
            return res;
        }

        // 初始化数据
        for (let i = 0; i < TOTAL_COUNT; i++) {
            data.push({
                id: i,
                text: getRandomText(),
                hasImage: Math.random() > 0.7, // 30% 概率有图
                imgHeight: Math.floor(Math.random() * 100) + 50 // 随机图片高度
            });
        }

        // ================= 核心类：VirtualList =================
        class VirtualList {
            constructor(containerId, listId, phantomId, listData) {
                this.container = document.getElementById(containerId);
                this.listContent = document.getElementById(listId);
                this.phantom = document.getElementById(phantomId);
                this.listData = listData;

                // 配置项
                this.estimatedHeight = 80; // 预估高度（Estimate Height）
                this.bufferSize = 5;      // 缓冲区大小（Buffer Zone）

                // 状态
                this.visibleData = [];
                this.positions = []; // 元数据：存储每一项的 top, bottom, height, value
                this.startIndex = 0;

                this.initPositions();
                this.initEvents();
                this.render(); // 首次渲染
            }

            // 初始化位置数据
            initPositions() {
                this.positions = this.listData.map((_, index) => ({
                    index,
                    height: this.estimatedHeight,
                    top: index * this.estimatedHeight,
                    bottom: (index + 1) * this.estimatedHeight,
                    value: 0 // 真实高度与预估高度的差值
                }));
                // 设置幽灵容器高度
                this.phantom.style.height = `${this.positions[this.positions.length - 1].bottom}px`;
            }

            // 初始化事件监听
            initEvents() {
                // 监听滚动事件（被动监听，提升性能）
                this.container.addEventListener('scroll', () => {
                    requestAnimationFrame(() => {
                        this.render();
                    });
                }, { passive: true });
            }

            // 二分查找：找到第一个 bottom > scrollTop 的项
            getStartIndex(scrollTop) {
                let start = 0;
                let end = this.positions.length - 1;
                let tempIndex = 0;

                while (start <= end) {
                    const midIndex = parseInt((start + end) / 2);
                    const midVal = this.positions[midIndex].bottom;

                    if (midVal === scrollTop) {
                        return midIndex + 1;
                    } else if (midVal < scrollTop) {
                        start = midIndex + 1;
                    } else if (midVal > scrollTop) {
                        tempIndex = midIndex;
                        end = midIndex - 1;
                    }
                }
                return tempIndex;
            }

            // 渲染核心逻辑
            render() {
                const scrollTop = this.container.scrollTop;
                const containerHeight = this.container.clientHeight;

                // 1. 计算可视区域数量
                const visibleCount = Math.ceil(containerHeight / this.estimatedHeight);
                // 2. 二分查找起始索引
                this.startIndex = this.getStartIndex(scrollTop);
                // 3. 加上缓冲区
                const start = Math.max(0, this.startIndex - this.bufferSize);
                const end = Math.min(this.listData.length - 1, this.startIndex + visibleCount + this.bufferSize);
                // 4. 截取可视数据
                this.visibleData = this.listData.slice(start, end + 1);

                // 5. 渲染DOM
                const startOffset = this.positions[start].top;
                this.listContent.style.transform = `translateY(${startOffset}px)`;
                this.listContent.innerHTML = this.visibleData.map(item => {
                    return `
                        <div class="list-item" data-index="${item.id}">
                            <div class="item-head">
                                <span class="item-title">${item.id}</span>
                                <span>pos: ${this.positions[item.id].top}px</span>
                            </div>
                            <div class="item-text">${item.text}</div>
                            ${item.hasImage ? `<div class="item-img" style="height: ${item.imgHeight}px"></div>` : ''}
                        </div>
                    `;
                }).join('');

                // 更新调试面板
                document.getElementById('render-count').innerText = this.visibleData.length;
                document.getElementById('start-index').innerText = start;

                // 6. 关键步骤：渲染后修正高度
                this.updatePositions(start);
            }

            // 动态修正高度（Dynamic Height Correction）
            updatePositions(start) {
                const nodes = this.listContent.children;
                if (!nodes || nodes.length === 0) return;

                let diff = 0; // 总差值
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    const index = parseInt(node.dataset.index);
                    const rect = node.getBoundingClientRect();
                    const realHeight = rect.height;
                    const oldHeight = this.positions[index].height;
                    const value = realHeight - oldHeight;

                    // 更新当前项的高度和差值
                    if (value !== 0) {
                        this.positions[index].height = realHeight;
                        this.positions[index].value = value;
                        diff += value;
                    }
                }

                // 如果有高度变化，需要更新后续所有项的top和bottom
                if (diff !== 0) {
                    for (let i = start + nodes.length; i < this.positions.length; i++) {
                        this.positions[i].top += diff;
                        this.positions[i].bottom += diff;
                    }
                    // 更新幽灵容器高度
                    this.phantom.style.height = `${this.positions[this.positions.length - 1].bottom}px`;
                }
            }
        }

        // ================= 启动虚拟列表 =================
        const vl = new VirtualList('list-view', 'list-content', 'list-phantom', data);

        // ================= 性能监控（FPS） =================
        let lastTime = 0;
        let frameCount = 0;
        const fpsElem = document.getElementById('fps');

        function calculateFPS() {
            const now = performance.now();
            frameCount++;

            if (now - lastTime >= 1000) {
                const fps = frameCount;
                fpsElem.innerText = fps;
                fpsElem.style.color = fps < 30 ? 'red' : '#fff';
                frameCount = 0;
                lastTime = now;
            }
            requestAnimationFrame(calculateFPS);
        }
        calculateFPS();
    </script>
</body>
</html>
